#!/usr/bin/env -S deno run --no-lock --allow-read --allow-run=deno --allow-env=CI,DENO_DIR
class AssertionError extends Error{constructor(message){super(message);this.name="AssertionError";}}function assert(expr,msg=""){if(!expr){throw new AssertionError(msg);}}const{hasOwn}=Object;function get(obj,key){if(hasOwn(obj,key)){return obj[key];}}function getForce(obj,key){const v=get(obj,key);assert(v!==undefined);return v;}function isNumber(x){if(typeof x==="number")return true;if(/^0x[0-9a-f]+$/i.test(String(x)))return true;return/^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(String(x));}function hasKey(obj,keys){let o=obj;keys.slice(0,-1).forEach(key=>{o=get(o,key)??{};});const key=keys[keys.length-1];return hasOwn(o,key);}function parseArgs(args,{"--":doubleDash=false,alias={},boolean:__boolean=false,default:defaults={},stopEarly=false,string=[],collect=[],negatable=[],unknown=i=>i}={}){const aliases={};const flags={bools:{},strings:{},unknownFn:unknown,allBools:false,collect:{},negatable:{}};if(alias!==undefined){for(const key in alias){const val=getForce(alias,key);if(typeof val==="string"){aliases[key]=[val];}else{aliases[key]=val;}for(const alias of getForce(aliases,key)){aliases[alias]=[key].concat(aliases[key].filter(y=>alias!==y));}}}if(__boolean!==undefined){if(typeof __boolean==="boolean"){flags.allBools=!!__boolean;}else{const booleanArgs=typeof __boolean==="string"?[__boolean]:__boolean;for(const key of booleanArgs.filter(Boolean)){flags.bools[key]=true;const alias=get(aliases,key);if(alias){for(const al of alias){flags.bools[al]=true;}}}}}if(string!==undefined){const stringArgs=typeof string==="string"?[string]:string;for(const key of stringArgs.filter(Boolean)){flags.strings[key]=true;const alias=get(aliases,key);if(alias){for(const al of alias){flags.strings[al]=true;}}}}if(collect!==undefined){const collectArgs=typeof collect==="string"?[collect]:collect;for(const key of collectArgs.filter(Boolean)){flags.collect[key]=true;const alias=get(aliases,key);if(alias){for(const al of alias){flags.collect[al]=true;}}}}if(negatable!==undefined){const negatableArgs=typeof negatable==="string"?[negatable]:negatable;for(const key of negatableArgs.filter(Boolean)){flags.negatable[key]=true;const alias=get(aliases,key);if(alias){for(const al of alias){flags.negatable[al]=true;}}}}const argv={_:[]};function argDefined(key,arg){return flags.allBools&&/^--[^=]+$/.test(arg)||get(flags.bools,key)||!!get(flags.strings,key)||!!get(aliases,key);}function setKey(obj,name,value,collect=true){let o=obj;const keys=name.split(".");keys.slice(0,-1).forEach(function(key){if(get(o,key)===undefined){o[key]={};}o=get(o,key);});const key=keys[keys.length-1];const collectable=collect&&!!get(flags.collect,name);if(!collectable){o[key]=value;}else if(get(o,key)===undefined){o[key]=[value];}else if(Array.isArray(get(o,key))){o[key].push(value);}else{o[key]=[get(o,key),value];}}function setArg(key,val,arg=undefined,collect){if(arg&&flags.unknownFn&&!argDefined(key,arg)){if(flags.unknownFn(arg,key,val)===false)return;}const value=!get(flags.strings,key)&&isNumber(val)?Number(val):val;setKey(argv,key,value,collect);const alias=get(aliases,key);if(alias){for(const x of alias){setKey(argv,x,value,collect);}}}function aliasIsBoolean(key){return getForce(aliases,key).some(x=>typeof get(flags.bools,x)==="boolean");}let notFlags=[];if(args.includes("--")){notFlags=args.slice(args.indexOf("--")+1);args=args.slice(0,args.indexOf("--"));}for(let i=0;i<args.length;i++){const arg=args[i];if(/^--.+=/.test(arg)){const m=arg.match(/^--([^=]+)=(.*)$/s);assert(m!==null);const[,key,value]=m;if(flags.bools[key]){const booleanValue=value!=="false";setArg(key,booleanValue,arg);}else{setArg(key,value,arg);}}else if(/^--no-.+/.test(arg)&&get(flags.negatable,arg.replace(/^--no-/,""))){const m=arg.match(/^--no-(.+)/);assert(m!==null);setArg(m[1],false,arg,false);}else if(/^--.+/.test(arg)){const m=arg.match(/^--(.+)/);assert(m!==null);const[,key]=m;const next=args[i+1];if(next!==undefined&&!/^-/.test(next)&&!get(flags.bools,key)&&!flags.allBools&&(get(aliases,key)?!aliasIsBoolean(key):true)){setArg(key,next,arg);i++;}else if(/^(true|false)$/.test(next)){setArg(key,next==="true",arg);i++;}else{setArg(key,get(flags.strings,key)?"":true,arg);}}else if(/^-[^-]+/.test(arg)){const letters=arg.slice(1,-1).split("");let broken=false;for(let j=0;j<letters.length;j++){const next=arg.slice(j+2);if(next==="-"){setArg(letters[j],next,arg);continue;}if(/[A-Za-z]/.test(letters[j])&&/=/.test(next)){setArg(letters[j],next.split(/=(.+)/)[1],arg);broken=true;break;}if(/[A-Za-z]/.test(letters[j])&&/-?\d+(\.\d*)?(e-?\d+)?$/.test(next)){setArg(letters[j],next,arg);broken=true;break;}if(letters[j+1]&&letters[j+1].match(/\W/)){setArg(letters[j],arg.slice(j+2),arg);broken=true;break;}else{setArg(letters[j],get(flags.strings,letters[j])?"":true,arg);}}const[key]=arg.slice(-1);if(!broken&&key!=="-"){if(args[i+1]&&!/^(-|--)[^-]/.test(args[i+1])&&!get(flags.bools,key)&&(get(aliases,key)?!aliasIsBoolean(key):true)){setArg(key,args[i+1],arg);i++;}else if(args[i+1]&&/^(true|false)$/.test(args[i+1])){setArg(key,args[i+1]==="true",arg);i++;}else{setArg(key,get(flags.strings,key)?"":true,arg);}}}else{if(!flags.unknownFn||flags.unknownFn(arg)!==false){argv._.push(flags.strings["_"]??!isNumber(arg)?arg:Number(arg));}if(stopEarly){argv._.push(...args.slice(i+1));break;}}}for(const[key,value]of Object.entries(defaults)){if(!hasKey(argv,key.split("."))){setKey(argv,key,value,false);if(aliases[key]){for(const x of aliases[key]){setKey(argv,x,value,false);}}}}for(const key of Object.keys(flags.bools)){if(!hasKey(argv,key.split("."))){const value=get(flags.collect,key)?[]:false;setKey(argv,key,value,false);}}for(const key of Object.keys(flags.strings)){if(!hasKey(argv,key.split("."))&&get(flags.collect,key)){setKey(argv,key,[],false);}}if(doubleDash){argv["--"]=[];for(const key of notFlags){argv["--"].push(key);}}else{for(const key of notFlags){argv._.push(key);}}return argv;}const encoder=new TextEncoder;function getTypeName(value){const type=typeof value;if(type!=="object"){return type;}else if(value===null){return"null";}else{return value?.constructor?.name??"object";}}function validateBinaryLike(source){if(typeof source==="string"){return encoder.encode(source);}else if(source instanceof Uint8Array){return source;}else if(source instanceof ArrayBuffer){return new Uint8Array(source);}throw new TypeError(`The input must be a Uint8Array, a string, or an ArrayBuffer. Received a value of the type ${getTypeName(source)}.`);}const hexTable=new TextEncoder().encode("0123456789abcdef");new TextEncoder;const textDecoder=new TextDecoder;function encodeHex(src){const u8=validateBinaryLike(src);const dst=new Uint8Array(u8.length*2);for(let i=0;i<dst.length;i++){const v=u8[i];dst[i*2]=hexTable[v>>4];dst[i*2+1]=hexTable[v&15];}return textDecoder.decode(dst);}const osType=(()=>{const{Deno:Deno1}=globalThis;if(typeof Deno1?.build?.os==="string"){return Deno1.build.os;}const{navigator}=globalThis;if(navigator?.appVersion?.includes?.("Win")){return"windows";}return"linux";})();const isWindows=osType==="windows";function assertPath(path){if(typeof path!=="string"){throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);}}function assertArg(path){assertPath(path);if(path.length===0)return".";}const CHAR_FORWARD_SLASH=47;function normalizeString(path,allowAboveRoot,separator,isPathSeparator){let res="";let lastSegmentLength=0;let lastSlash=-1;let dots=0;let code;for(let i=0,len=path.length;i<=len;++i){if(i<len)code=path.charCodeAt(i);else if(isPathSeparator(code))break;else code=CHAR_FORWARD_SLASH;if(isPathSeparator(code)){if(lastSlash===i-1||dots===1){}else if(lastSlash!==i-1&&dots===2){if(res.length<2||lastSegmentLength!==2||res.charCodeAt(res.length-1)!==46||res.charCodeAt(res.length-2)!==46){if(res.length>2){const lastSlashIndex=res.lastIndexOf(separator);if(lastSlashIndex===-1){res="";lastSegmentLength=0;}else{res=res.slice(0,lastSlashIndex);lastSegmentLength=res.length-1-res.lastIndexOf(separator);}lastSlash=i;dots=0;continue;}else if(res.length===2||res.length===1){res="";lastSegmentLength=0;lastSlash=i;dots=0;continue;}}if(allowAboveRoot){if(res.length>0)res+=`${separator}..`;else res="..";lastSegmentLength=2;}}else{if(res.length>0)res+=separator+path.slice(lastSlash+1,i);else res=path.slice(lastSlash+1,i);lastSegmentLength=i-lastSlash-1;}lastSlash=i;dots=0;}else if(code===46&&dots!==-1){++dots;}else{dots=-1;}}return res;}function isPosixPathSeparator(code){return code===47;}function normalize(path){assertArg(path);const isAbsolute=isPosixPathSeparator(path.charCodeAt(0));const trailingSeparator=isPosixPathSeparator(path.charCodeAt(path.length-1));path=normalizeString(path,!isAbsolute,"/",isPosixPathSeparator);if(path.length===0&&!isAbsolute)path=".";if(path.length>0&&trailingSeparator)path+="/";if(isAbsolute)return`/${path}`;return path;}function join(...paths){if(paths.length===0)return".";let joined;for(let i=0,len=paths.length;i<len;++i){const path=paths[i];assertPath(path);if(path.length>0){if(!joined)joined=path;else joined+=`/${path}`;}}if(!joined)return".";return normalize(joined);}function isPathSeparator(code){return code===47||code===92;}function isWindowsDeviceRoot(code){return code>=97&&code<=122||code>=65&&code<=90;}function normalize1(path){assertArg(path);const len=path.length;let rootEnd=0;let device;let isAbsolute=false;const code=path.charCodeAt(0);if(len>1){if(isPathSeparator(code)){isAbsolute=true;if(isPathSeparator(path.charCodeAt(1))){let j=2;let last=j;for(;j<len;++j){if(isPathSeparator(path.charCodeAt(j)))break;}if(j<len&&j!==last){const firstPart=path.slice(last,j);last=j;for(;j<len;++j){if(!isPathSeparator(path.charCodeAt(j)))break;}if(j<len&&j!==last){last=j;for(;j<len;++j){if(isPathSeparator(path.charCodeAt(j)))break;}if(j===len){return`\\\\${firstPart}\\${path.slice(last)}\\`;}else if(j!==last){device=`\\\\${firstPart}\\${path.slice(last,j)}`;rootEnd=j;}}}}else{rootEnd=1;}}else if(isWindowsDeviceRoot(code)){if(path.charCodeAt(1)===58){device=path.slice(0,2);rootEnd=2;if(len>2){if(isPathSeparator(path.charCodeAt(2))){isAbsolute=true;rootEnd=3;}}}}}else if(isPathSeparator(code)){return"\\";}let tail;if(rootEnd<len){tail=normalizeString(path.slice(rootEnd),!isAbsolute,"\\",isPathSeparator);}else{tail="";}if(tail.length===0&&!isAbsolute)tail=".";if(tail.length>0&&isPathSeparator(path.charCodeAt(len-1))){tail+="\\";}if(device===undefined){if(isAbsolute){if(tail.length>0)return`\\${tail}`;else return"\\";}else if(tail.length>0){return tail;}else{return"";}}else if(isAbsolute){if(tail.length>0)return`${device}\\${tail}`;else return`${device}\\`;}else if(tail.length>0){return device+tail;}else{return device;}}function join1(...paths){if(paths.length===0)return".";let joined;let firstPart=null;for(let i=0;i<paths.length;++i){const path=paths[i];assertPath(path);if(path.length>0){if(joined===undefined)joined=firstPart=path;else joined+=`\\${path}`;}}if(joined===undefined)return".";let needsReplace=true;let slashCount=0;assert(firstPart!==null);if(isPathSeparator(firstPart.charCodeAt(0))){++slashCount;const firstLen=firstPart.length;if(firstLen>1){if(isPathSeparator(firstPart.charCodeAt(1))){++slashCount;if(firstLen>2){if(isPathSeparator(firstPart.charCodeAt(2)))++slashCount;else{needsReplace=false;}}}}}if(needsReplace){for(;slashCount<joined.length;++slashCount){if(!isPathSeparator(joined.charCodeAt(slashCount)))break;}if(slashCount>=2)joined=`\\${joined.slice(slashCount)}`;}return normalize1(joined);}function join2(...paths){return isWindows?join1(...paths):join(...paths);}function assertArg1(url){url=url instanceof URL?url:new URL(url);if(url.protocol!=="file:"){throw new TypeError("Must be a file URL.");}return url;}function fromFileUrl(url){url=assertArg1(url);return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g,"%25"));}function fromFileUrl1(url){url=assertArg1(url);let path=decodeURIComponent(url.pathname.replace(/\//g,"\\").replace(/%(?![0-9A-Fa-f]{2})/g,"%25")).replace(/^\\*([A-Za-z]:)(\\|$)/,"$1\\");if(url.hostname!==""){path=`\\\\${url.hostname}${path}`;}return path;}function fromFileUrl2(url){return isWindows?fromFileUrl1(url):fromFileUrl(url);}function toPathString(pathUrl){return pathUrl instanceof URL?fromFileUrl2(pathUrl):pathUrl;}function stripTrailingSeparators(segment,isSep){if(segment.length<=1){return segment;}let end=segment.length;for(let i=segment.length-1;i>0;i--){if(isSep(segment.charCodeAt(i))){end=i;}else{break;}}return segment.slice(0,end);}function resolve(...pathSegments){let resolvedPath="";let resolvedAbsolute=false;for(let i=pathSegments.length-1;i>=-1&&!resolvedAbsolute;i--){let path;if(i>=0)path=pathSegments[i];else{const{Deno:Deno1}=globalThis;if(typeof Deno1?.cwd!=="function"){throw new TypeError("Resolved a relative path without a CWD.");}path=Deno1.cwd();}assertPath(path);if(path.length===0){continue;}resolvedPath=`${path}/${resolvedPath}`;resolvedAbsolute=isPosixPathSeparator(path.charCodeAt(0));}resolvedPath=normalizeString(resolvedPath,!resolvedAbsolute,"/",isPosixPathSeparator);if(resolvedAbsolute){if(resolvedPath.length>0)return`/${resolvedPath}`;else return"/";}else if(resolvedPath.length>0)return resolvedPath;else return".";}function resolve1(...pathSegments){let resolvedDevice="";let resolvedTail="";let resolvedAbsolute=false;for(let i=pathSegments.length-1;i>=-1;i--){let path;const{Deno:Deno1}=globalThis;if(i>=0){path=pathSegments[i];}else if(!resolvedDevice){if(typeof Deno1?.cwd!=="function"){throw new TypeError("Resolved a drive-letter-less path without a CWD.");}path=Deno1.cwd();}else{if(typeof Deno1?.env?.get!=="function"||typeof Deno1?.cwd!=="function"){throw new TypeError("Resolved a relative path without a CWD.");}path=Deno1.cwd();if(path===undefined||path.slice(0,3).toLowerCase()!==`${resolvedDevice.toLowerCase()}\\`){path=`${resolvedDevice}\\`;}}assertPath(path);const len=path.length;if(len===0)continue;let rootEnd=0;let device="";let isAbsolute=false;const code=path.charCodeAt(0);if(len>1){if(isPathSeparator(code)){isAbsolute=true;if(isPathSeparator(path.charCodeAt(1))){let j=2;let last=j;for(;j<len;++j){if(isPathSeparator(path.charCodeAt(j)))break;}if(j<len&&j!==last){const firstPart=path.slice(last,j);last=j;for(;j<len;++j){if(!isPathSeparator(path.charCodeAt(j)))break;}if(j<len&&j!==last){last=j;for(;j<len;++j){if(isPathSeparator(path.charCodeAt(j)))break;}if(j===len){device=`\\\\${firstPart}\\${path.slice(last)}`;rootEnd=j;}else if(j!==last){device=`\\\\${firstPart}\\${path.slice(last,j)}`;rootEnd=j;}}}}else{rootEnd=1;}}else if(isWindowsDeviceRoot(code)){if(path.charCodeAt(1)===58){device=path.slice(0,2);rootEnd=2;if(len>2){if(isPathSeparator(path.charCodeAt(2))){isAbsolute=true;rootEnd=3;}}}}}else if(isPathSeparator(code)){rootEnd=1;isAbsolute=true;}if(device.length>0&&resolvedDevice.length>0&&device.toLowerCase()!==resolvedDevice.toLowerCase()){continue;}if(resolvedDevice.length===0&&device.length>0){resolvedDevice=device;}if(!resolvedAbsolute){resolvedTail=`${path.slice(rootEnd)}\\${resolvedTail}`;resolvedAbsolute=isAbsolute;}if(resolvedAbsolute&&resolvedDevice.length>0)break;}resolvedTail=normalizeString(resolvedTail,!resolvedAbsolute,"\\",isPathSeparator);return resolvedDevice+(resolvedAbsolute?"\\":"")+resolvedTail||".";}Deno.build.os==="windows";async function exists(path,options){try{const stat=await Deno.stat(path);if(options&&(options.isReadable||options.isDirectory||options.isFile)){if(options.isDirectory&&options.isFile){throw new TypeError("ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together.");}if(options.isDirectory&&!stat.isDirectory||options.isFile&&!stat.isFile){return false;}if(options.isReadable){if(stat.mode===null){return true;}if(Deno.uid()===stat.uid){return(stat.mode&256)===256;}else if(Deno.gid()===stat.gid){return(stat.mode&32)===32;}return(stat.mode&4)===4;}}return true;}catch(error){if(error instanceof Deno.errors.NotFound){return false;}if(error instanceof Deno.errors.PermissionDenied){if((await Deno.permissions.query({name:"read",path})).state==="granted"){return!options?.isReadable;}}throw error;}}function existsSync(path,options){try{const stat=Deno.statSync(path);if(options&&(options.isReadable||options.isDirectory||options.isFile)){if(options.isDirectory&&options.isFile){throw new TypeError("ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together.");}if(options.isDirectory&&!stat.isDirectory||options.isFile&&!stat.isFile){return false;}if(options.isReadable){if(stat.mode===null){return true;}if(Deno.uid()===stat.uid){return(stat.mode&256)===256;}else if(Deno.gid()===stat.gid){return(stat.mode&32)===32;}return(stat.mode&4)===4;}}return true;}catch(error){if(error instanceof Deno.errors.NotFound){return false;}if(error instanceof Deno.errors.PermissionDenied){if(Deno.permissions.querySync({name:"read",path}).state==="granted"){return!options?.isReadable;}}throw error;}}function normalize2(path){return isWindows?normalize1(path):normalize(path);}function stripSuffix(name,suffix){if(suffix.length>=name.length){return name;}const lenDiff=name.length-suffix.length;for(let i=suffix.length-1;i>=0;--i){if(name.charCodeAt(lenDiff+i)!==suffix.charCodeAt(i)){return name;}}return name.slice(0,-suffix.length);}function lastPathSegment(path,isSep,start=0){let matchedNonSeparator=false;let end=path.length;for(let i=path.length-1;i>=start;--i){if(isSep(path.charCodeAt(i))){if(matchedNonSeparator){start=i+1;break;}}else if(!matchedNonSeparator){matchedNonSeparator=true;end=i+1;}}return path.slice(start,end);}function assertArgs(path,suffix){assertPath(path);if(path.length===0)return path;if(typeof suffix!=="string"){throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);}}function basename(path,suffix=""){assertArgs(path,suffix);const lastSegment=lastPathSegment(path,isPosixPathSeparator);const strippedSegment=stripTrailingSeparators(lastSegment,isPosixPathSeparator);return suffix?stripSuffix(strippedSegment,suffix):strippedSegment;}function basename1(path,suffix=""){assertArgs(path,suffix);let start=0;if(path.length>=2){const drive=path.charCodeAt(0);if(isWindowsDeviceRoot(drive)){if(path.charCodeAt(1)===58)start=2;}}const lastSegment=lastPathSegment(path,isPathSeparator,start);const strippedSegment=stripTrailingSeparators(lastSegment,isPathSeparator);return suffix?stripSuffix(strippedSegment,suffix):strippedSegment;}function basename2(path,suffix=""){return isWindows?basename1(path,suffix):basename(path,suffix);}async function createWalkEntry(path){path=toPathString(path);path=normalize2(path);const name=basename2(path);const info=await Deno.stat(path);return{path,name,isFile:info.isFile,isDirectory:info.isDirectory,isSymlink:info.isSymlink};}class WalkError extends Error{root;constructor(cause,root){super(`${cause instanceof Error?cause.message:cause} for path "${root}"`);this.cause=cause;this.name="WalkError";this.root=root;}}function include(path,exts,match,skip){if(exts&&!exts.some(ext=>path.endsWith(ext))){return false;}if(match&&!match.some(pattern=>!!path.match(pattern))){return false;}if(skip&&skip.some(pattern=>!!path.match(pattern))){return false;}return true;}function wrapErrorWithPath(err,root){if(err instanceof WalkError)return err;return new WalkError(err,root);}async function*walk(root,{maxDepth=Infinity,includeFiles=true,includeDirs=true,includeSymlinks=true,followSymlinks=false,canonicalize=true,exts=undefined,match=undefined,skip=undefined}={}){if(maxDepth<0){return;}root=toPathString(root);if(includeDirs&&include(root,exts,match,skip)){yield await createWalkEntry(root);}if(maxDepth<1||!include(root,undefined,undefined,skip)){return;}try{for await(const entry of Deno.readDir(root)){let path=join2(root,entry.name);let{isSymlink,isDirectory}=entry;if(isSymlink){if(!followSymlinks){if(includeSymlinks&&include(path,exts,match,skip)){yield{path,...entry};}continue;}const realPath=await Deno.realPath(path);if(canonicalize){path=realPath;}({isSymlink,isDirectory}=await Deno.lstat(realPath));}if(isSymlink||isDirectory){yield*walk(path,{maxDepth:maxDepth-1,includeFiles,includeDirs,includeSymlinks,followSymlinks,exts,match,skip});}else if(includeFiles&&include(path,exts,match,skip)){yield{path,...entry};}}}catch(err){throw wrapErrorWithPath(err,normalize2(root));}}Deno.build.os==="windows";new Deno.errors.AlreadyExists("dest already exists.");Deno.build.os==="windows";const LF="\n";const CRLF="\r\n";Deno?.build.os==="windows"?CRLF:LF;function parse(text,{allowTrailingComma=true}={}){if(new.target){throw new TypeError("parse is not a constructor");}return new JSONCParser(text,{allowTrailingComma}).parse();}const originalJSONParse=globalThis.JSON.parse;class JSONCParser{#whitespace=new Set(" 	\r\n");#numberEndToken=new Set([..."[]{}:,/",...this.#whitespace]);#text;#length;#tokenized;#options;constructor(text,options){this.#text=`${text}`;this.#length=this.#text.length;this.#tokenized=this.#tokenize();this.#options=options;}parse(){const token=this.#getNext();const res=this.#parseJsonValue(token);const{done,value}=this.#tokenized.next();if(!done){throw new SyntaxError(buildErrorMessage(value));}return res;}#getNext(){const{done,value}=this.#tokenized.next();if(done){throw new SyntaxError("Unexpected end of JSONC input");}return value;}*#tokenize(){for(let i=0;i<this.#length;i++){if(this.#whitespace.has(this.#text[i])){continue;}if(this.#text[i]==="/"&&this.#text[i+1]==="*"){i+=2;let hasEndOfComment=false;for(;i<this.#length;i++){if(this.#text[i]==="*"&&this.#text[i+1]==="/"){hasEndOfComment=true;break;}}if(!hasEndOfComment){throw new SyntaxError("Unexpected end of JSONC input");}i++;continue;}if(this.#text[i]==="/"&&this.#text[i+1]==="/"){i+=2;for(;i<this.#length;i++){if(this.#text[i]==="\n"||this.#text[i]==="\r"){break;}}continue;}switch(this.#text[i]){case"{":yield{type:"BeginObject",position:i};break;case"}":yield{type:"EndObject",position:i};break;case"[":yield{type:"BeginArray",position:i};break;case"]":yield{type:"EndArray",position:i};break;case":":yield{type:"NameSeparator",position:i};break;case",":yield{type:"ValueSeparator",position:i};break;case'"':{const startIndex=i;let shouldEscapeNext=false;i++;for(;i<this.#length;i++){if(this.#text[i]==='"'&&!shouldEscapeNext){break;}shouldEscapeNext=this.#text[i]==="\\"&&!shouldEscapeNext;}yield{type:"String",sourceText:this.#text.substring(startIndex,i+1),position:startIndex};break;}default:{const startIndex=i;for(;i<this.#length;i++){if(this.#numberEndToken.has(this.#text[i])){break;}}i--;yield{type:"NullOrTrueOrFalseOrNumber",sourceText:this.#text.substring(startIndex,i+1),position:startIndex};}}}}#parseJsonValue(value){switch(value.type){case"BeginObject":return this.#parseObject();case"BeginArray":return this.#parseArray();case"NullOrTrueOrFalseOrNumber":return this.#parseNullOrTrueOrFalseOrNumber(value);case"String":return this.#parseString(value);default:throw new SyntaxError(buildErrorMessage(value));}}#parseObject(){const target={};for(let isFirst=true;;isFirst=false){const token1=this.#getNext();if((isFirst||this.#options.allowTrailingComma)&&token1.type==="EndObject"){return target;}if(token1.type!=="String"){throw new SyntaxError(buildErrorMessage(token1));}const key=this.#parseString(token1);const token2=this.#getNext();if(token2.type!=="NameSeparator"){throw new SyntaxError(buildErrorMessage(token2));}const token3=this.#getNext();Object.defineProperty(target,key,{value:this.#parseJsonValue(token3),writable:true,enumerable:true,configurable:true});const token4=this.#getNext();if(token4.type==="EndObject"){return target;}if(token4.type!=="ValueSeparator"){throw new SyntaxError(buildErrorMessage(token4));}}}#parseArray(){const target=[];for(let isFirst=true;;isFirst=false){const token1=this.#getNext();if((isFirst||this.#options.allowTrailingComma)&&token1.type==="EndArray"){return target;}target.push(this.#parseJsonValue(token1));const token2=this.#getNext();if(token2.type==="EndArray"){return target;}if(token2.type!=="ValueSeparator"){throw new SyntaxError(buildErrorMessage(token2));}}}#parseString(value){let parsed;try{parsed=originalJSONParse(value.sourceText);}catch{throw new SyntaxError(buildErrorMessage(value));}assert(typeof parsed==="string");return parsed;}#parseNullOrTrueOrFalseOrNumber(value){if(value.sourceText==="null"){return null;}if(value.sourceText==="true"){return true;}if(value.sourceText==="false"){return false;}let parsed;try{parsed=originalJSONParse(value.sourceText);}catch{throw new SyntaxError(buildErrorMessage(value));}assert(typeof parsed==="number");return parsed;}}function buildErrorMessage({type,sourceText,position}){let token="";switch(type){case"BeginObject":token="{";break;case"EndObject":token="}";break;case"BeginArray":token="[";break;case"EndArray":token="]";break;case"NameSeparator":token=":";break;case"ValueSeparator":token=",";break;case"NullOrTrueOrFalseOrNumber":case"String":token=30<sourceText.length?`${sourceText.slice(0,30)}...`:sourceText;break;default:throw new Error("unreachable");}return`Unexpected token ${token} in JSONC at position ${position}`;}const LogLevels={NOTSET:0,DEBUG:10,INFO:20,WARNING:30,ERROR:40,CRITICAL:50,0:"NOTSET",10:"DEBUG",20:"INFO",30:"WARNING",40:"ERROR",50:"CRITICAL"};Object.keys(LogLevels).filter(key=>isNaN(Number(key)));const byLevel={[LogLevels.NOTSET]:"NOTSET",[LogLevels.DEBUG]:"DEBUG",[LogLevels.INFO]:"INFO",[LogLevels.WARNING]:"WARNING",[LogLevels.ERROR]:"ERROR",[LogLevels.CRITICAL]:"CRITICAL"};function getLevelByName(name){const level=LogLevels[name];if(level!==undefined){return level;}throw new Error(`no log level found for name: ${name}`);}function getLevelName(level){const levelName=byLevel[level];if(levelName){return levelName;}throw new Error(`no level name found for level: ${level}`);}class LogRecord{msg;#args;#datetime;level;levelName;loggerName;constructor(options){this.msg=options.msg;this.#args=[...options.args];this.level=options.level;this.loggerName=options.loggerName;this.#datetime=new Date;this.levelName=getLevelName(options.level);}get args(){return[...this.#args];}get datetime(){return new Date(this.#datetime.getTime());}}class Logger{#level;#handlers;#loggerName;constructor(loggerName,levelName,options={}){this.#loggerName=loggerName;this.#level=getLevelByName(levelName);this.#handlers=options.handlers||[];}get level(){return this.#level;}set level(level){try{this.#level=getLevelByName(getLevelName(level));}catch(_){throw new TypeError(`Invalid log level: ${level}`);}}get levelName(){return getLevelName(this.#level);}set levelName(levelName){this.#level=getLevelByName(levelName);}get loggerName(){return this.#loggerName;}set handlers(hndls){this.#handlers=hndls;}get handlers(){return this.#handlers;}#_log(level,msg,...args){if(this.level>level){return msg instanceof Function?undefined:msg;}let fnResult;let logMessage;if(msg instanceof Function){fnResult=msg();logMessage=this.asString(fnResult);}else{logMessage=this.asString(msg);}const record=new LogRecord({msg:logMessage,args:args,level:level,loggerName:this.loggerName});this.#handlers.forEach(handler=>{handler.handle(record);});return msg instanceof Function?fnResult:msg;}asString(data,isProperty=false){if(typeof data==="string"){if(isProperty)return`"${data}"`;return data;}else if(data===null||typeof data==="number"||typeof data==="bigint"||typeof data==="boolean"||typeof data==="undefined"||typeof data==="symbol"){return String(data);}else if(data instanceof Error){return data.stack;}else if(typeof data==="object"){return`{${Object.entries(data).map(([k,v])=>`"${k}":${this.asString(v,true)}`).join(",")}}`;}return"undefined";}debug(msg,...args){return this.#_log(LogLevels.DEBUG,msg,...args);}info(msg,...args){return this.#_log(LogLevels.INFO,msg,...args);}warning(msg,...args){return this.#_log(LogLevels.WARNING,msg,...args);}error(msg,...args){return this.#_log(LogLevels.ERROR,msg,...args);}critical(msg,...args){return this.#_log(LogLevels.CRITICAL,msg,...args);}}const{Deno:Deno1}=globalThis;const noColor=typeof Deno1?.noColor==="boolean"?Deno1.noColor:false;let enabled=!noColor;function code(open,close){return{open:`\x1b[${open.join(";")}m`,close:`\x1b[${close}m`,regexp:new RegExp(`\\x1b\\[${close}m`,"g")};}function run(str,code){return enabled?`${code.open}${str.replace(code.regexp,code.open)}${code.close}`:str;}function bold(str){return run(str,code([1],22));}function red(str){return run(str,code([31],39));}function yellow(str){return run(str,code([33],39));}function blue(str){return run(str,code([34],39));}new RegExp(["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TXZcf-nq-uy=><~]))"].join("|"),"g");function copy(src,dst,off=0){off=Math.max(0,Math.min(off,dst.byteLength));const dstBytesAvailable=dst.byteLength-off;if(src.byteLength>dstBytesAvailable){src=src.subarray(0,dstBytesAvailable);}dst.set(src,off);return src.byteLength;}class AbstractBufBase{buf;usedBufferBytes=0;err=null;constructor(buf){this.buf=buf;}size(){return this.buf.byteLength;}available(){return this.buf.byteLength-this.usedBufferBytes;}buffered(){return this.usedBufferBytes;}}class BufWriterSync extends AbstractBufBase{#writer;static create(writer,size=4096){return writer instanceof BufWriterSync?writer:new BufWriterSync(writer,size);}constructor(writer,size=4096){super(new Uint8Array(size<=0?4096:size));this.#writer=writer;}reset(w){this.err=null;this.usedBufferBytes=0;this.#writer=w;}flush(){if(this.err!==null)throw this.err;if(this.usedBufferBytes===0)return;try{const p=this.buf.subarray(0,this.usedBufferBytes);let nwritten=0;while(nwritten<p.length){nwritten+=this.#writer.writeSync(p.subarray(nwritten));}}catch(e){if(e instanceof Error){this.err=e;}throw e;}this.buf=new Uint8Array(this.buf.length);this.usedBufferBytes=0;}writeSync(data){if(this.err!==null)throw this.err;if(data.length===0)return 0;let totalBytesWritten=0;let numBytesWritten=0;while(data.byteLength>this.available()){if(this.buffered()===0){try{numBytesWritten=this.#writer.writeSync(data);}catch(e){if(e instanceof Error){this.err=e;}throw e;}}else{numBytesWritten=copy(data,this.buf,this.usedBufferBytes);this.usedBufferBytes+=numBytesWritten;this.flush();}totalBytesWritten+=numBytesWritten;data=data.subarray(numBytesWritten);}numBytesWritten=copy(data,this.buf,this.usedBufferBytes);this.usedBufferBytes+=numBytesWritten;totalBytesWritten+=numBytesWritten;return totalBytesWritten;}}const DEFAULT_FORMATTER="{levelName} {msg}";class BaseHandler{level;levelName;formatter;constructor(levelName,options={}){this.level=getLevelByName(levelName);this.levelName=levelName;this.formatter=options.formatter||DEFAULT_FORMATTER;}handle(logRecord){if(this.level>logRecord.level)return;const msg=this.format(logRecord);this.log(msg);}format(logRecord){if(this.formatter instanceof Function){return this.formatter(logRecord);}return this.formatter.replace(/{([^\s}]+)}/g,(match,p1)=>{const value=logRecord[p1];if(value===undefined){return match;}return String(value);});}log(_msg){}setup(){}destroy(){}}class ConsoleHandler extends BaseHandler{#useColors;constructor(levelName,options={}){super(levelName,options);this.#useColors=options.useColors??true;}format(logRecord){let msg=super.format(logRecord);if(this.#useColors){msg=this.applyColors(msg,logRecord.level);}return msg;}applyColors(msg,level){switch(level){case LogLevels.INFO:msg=blue(msg);break;case LogLevels.WARNING:msg=yellow(msg);break;case LogLevels.ERROR:msg=red(msg);break;case LogLevels.CRITICAL:msg=bold(red(msg));break;default:break;}return msg;}log(msg){console.log(msg);}}class WriterHandler extends BaseHandler{_writer;#encoder=new TextEncoder;}class FileHandler extends WriterHandler{_file;_buf;_filename;_mode;_openOptions;_encoder=new TextEncoder;#unloadCallback=(()=>{this.destroy();}).bind(this);constructor(levelName,options){super(levelName,options);this._filename=options.filename;this._mode=options.mode?options.mode:"a";this._openOptions={createNew:this._mode==="x",create:this._mode!=="x",append:this._mode==="a",truncate:this._mode!=="a",write:true};}setup(){this._file=Deno.openSync(this._filename,this._openOptions);this._writer=this._file;this._buf=new BufWriterSync(this._file);addEventListener("unload",this.#unloadCallback);}handle(logRecord){super.handle(logRecord);if(logRecord.level>LogLevels.ERROR){this.flush();}}log(msg){if(this._encoder.encode(msg).byteLength+1>this._buf.available()){this.flush();}this._buf.writeSync(this._encoder.encode(msg+"\n"));}flush(){if(this._buf?.buffered()>0){this._buf.flush();}}destroy(){this.flush();this._file?.close();this._file=undefined;removeEventListener("unload",this.#unloadCallback);}}class RotatingFileHandler extends FileHandler{#maxBytes;#maxBackupCount;#currentFileSize=0;constructor(levelName,options){super(levelName,options);this.#maxBytes=options.maxBytes;this.#maxBackupCount=options.maxBackupCount;}setup(){if(this.#maxBytes<1){this.destroy();throw new Error("maxBytes cannot be less than 1");}if(this.#maxBackupCount<1){this.destroy();throw new Error("maxBackupCount cannot be less than 1");}super.setup();if(this._mode==="w"){for(let i=1;i<=this.#maxBackupCount;i++){try{Deno.removeSync(this._filename+"."+i);}catch(error){if(!(error instanceof Deno.errors.NotFound)){throw error;}}}}else if(this._mode==="x"){for(let i=1;i<=this.#maxBackupCount;i++){if(existsSync(this._filename+"."+i)){this.destroy();throw new Deno.errors.AlreadyExists("Backup log file "+this._filename+"."+i+" already exists");}}}else{this.#currentFileSize=Deno.statSync(this._filename).size;}}log(msg){const msgByteLength=this._encoder.encode(msg).byteLength+1;if(this.#currentFileSize+msgByteLength>this.#maxBytes){this.rotateLogFiles();this.#currentFileSize=0;}super.log(msg);this.#currentFileSize+=msgByteLength;}rotateLogFiles(){this._buf.flush();this._file.close();for(let i=this.#maxBackupCount-1;i>=0;i--){const source=this._filename+(i===0?"":"."+i);const dest=this._filename+"."+(i+1);if(existsSync(source)){Deno.renameSync(source,dest);}}this._file=Deno.openSync(this._filename,this._openOptions);this._writer=this._file;this._buf=new BufWriterSync(this._file);}}const DEFAULT_LEVEL="INFO";const DEFAULT_CONFIG={handlers:{default:new ConsoleHandler(DEFAULT_LEVEL)},loggers:{default:{level:DEFAULT_LEVEL,handlers:["default"]}}};const state={handlers:new Map,loggers:new Map,config:DEFAULT_CONFIG};const handlers={BaseHandler,ConsoleHandler,WriterHandler,FileHandler,RotatingFileHandler};function getLogger(name){if(!name){const d=state.loggers.get("default");assert(d!==undefined,`"default" logger must be set for getting logger without name`);return d;}const result=state.loggers.get(name);if(!result){const logger=new Logger(name,"NOTSET",{handlers:[]});state.loggers.set(name,logger);return logger;}return result;}function debug(msg,...args){if(msg instanceof Function){return getLogger("default").debug(msg,...args);}return getLogger("default").debug(msg,...args);}function warning(msg,...args){if(msg instanceof Function){return getLogger("default").warning(msg,...args);}return getLogger("default").warning(msg,...args);}function error(msg,...args){if(msg instanceof Function){return getLogger("default").error(msg,...args);}return getLogger("default").error(msg,...args);}function setup(config){state.config={handlers:{...DEFAULT_CONFIG.handlers,...config.handlers},loggers:{...DEFAULT_CONFIG.loggers,...config.loggers}};state.handlers.forEach(handler=>{handler.destroy();});state.handlers.clear();const handlers=state.config.handlers||{};for(const handlerName in handlers){const handler=handlers[handlerName];handler.setup();state.handlers.set(handlerName,handler);}state.loggers.clear();const loggers=state.config.loggers||{};for(const loggerName in loggers){const loggerConfig=loggers[loggerName];const handlerNames=loggerConfig.handlers||[];const handlers=[];handlerNames.forEach(handlerName=>{const handler=state.handlers.get(handlerName);if(handler){handlers.push(handler);}});const levelName=loggerConfig.level||DEFAULT_LEVEL;const logger=new Logger(loggerName,levelName,{handlers:handlers});state.loggers.set(loggerName,logger);}}setup(DEFAULT_CONFIG);function assertArgs1(from,to){assertPath(from);assertPath(to);if(from===to)return"";}function relative(from,to){assertArgs1(from,to);from=resolve(from);to=resolve(to);if(from===to)return"";let fromStart=1;const fromEnd=from.length;for(;fromStart<fromEnd;++fromStart){if(!isPosixPathSeparator(from.charCodeAt(fromStart)))break;}const fromLen=fromEnd-fromStart;let toStart=1;const toEnd=to.length;for(;toStart<toEnd;++toStart){if(!isPosixPathSeparator(to.charCodeAt(toStart)))break;}const toLen=toEnd-toStart;const length=fromLen<toLen?fromLen:toLen;let lastCommonSep=-1;let i=0;for(;i<=length;++i){if(i===length){if(toLen>length){if(isPosixPathSeparator(to.charCodeAt(toStart+i))){return to.slice(toStart+i+1);}else if(i===0){return to.slice(toStart+i);}}else if(fromLen>length){if(isPosixPathSeparator(from.charCodeAt(fromStart+i))){lastCommonSep=i;}else if(i===0){lastCommonSep=0;}}break;}const fromCode=from.charCodeAt(fromStart+i);const toCode=to.charCodeAt(toStart+i);if(fromCode!==toCode)break;else if(isPosixPathSeparator(fromCode))lastCommonSep=i;}let out="";for(i=fromStart+lastCommonSep+1;i<=fromEnd;++i){if(i===fromEnd||isPosixPathSeparator(from.charCodeAt(i))){if(out.length===0)out+="..";else out+="/..";}}if(out.length>0)return out+to.slice(toStart+lastCommonSep);else{toStart+=lastCommonSep;if(isPosixPathSeparator(to.charCodeAt(toStart)))++toStart;return to.slice(toStart);}}function relative1(from,to){assertArgs1(from,to);const fromOrig=resolve1(from);const toOrig=resolve1(to);if(fromOrig===toOrig)return"";from=fromOrig.toLowerCase();to=toOrig.toLowerCase();if(from===to)return"";let fromStart=0;let fromEnd=from.length;for(;fromStart<fromEnd;++fromStart){if(from.charCodeAt(fromStart)!==92)break;}for(;fromEnd-1>fromStart;--fromEnd){if(from.charCodeAt(fromEnd-1)!==92)break;}const fromLen=fromEnd-fromStart;let toStart=0;let toEnd=to.length;for(;toStart<toEnd;++toStart){if(to.charCodeAt(toStart)!==92)break;}for(;toEnd-1>toStart;--toEnd){if(to.charCodeAt(toEnd-1)!==92)break;}const toLen=toEnd-toStart;const length=fromLen<toLen?fromLen:toLen;let lastCommonSep=-1;let i=0;for(;i<=length;++i){if(i===length){if(toLen>length){if(to.charCodeAt(toStart+i)===92){return toOrig.slice(toStart+i+1);}else if(i===2){return toOrig.slice(toStart+i);}}if(fromLen>length){if(from.charCodeAt(fromStart+i)===92){lastCommonSep=i;}else if(i===2){lastCommonSep=3;}}break;}const fromCode=from.charCodeAt(fromStart+i);const toCode=to.charCodeAt(toStart+i);if(fromCode!==toCode)break;else if(fromCode===92)lastCommonSep=i;}if(i!==length&&lastCommonSep===-1){return toOrig;}let out="";if(lastCommonSep===-1)lastCommonSep=0;for(i=fromStart+lastCommonSep+1;i<=fromEnd;++i){if(i===fromEnd||from.charCodeAt(i)===92){if(out.length===0)out+="..";else out+="\\..";}}if(out.length>0){return out+toOrig.slice(toStart+lastCommonSep,toEnd);}else{toStart+=lastCommonSep;if(toOrig.charCodeAt(toStart)===92)++toStart;return toOrig.slice(toStart,toEnd);}}function relative2(from,to){return isWindows?relative1(from,to):relative(from,to);}var m=Object.create;var E=Object.defineProperty;var T=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var X=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var w=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),D=(t,e)=>{for(var s in e)E(t,s,{get:e[s],enumerable:!0});},a=(t,e,s,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of y(e))!b.call(t,n)&&n!==s&&E(t,n,{get:()=>e[n],enumerable:!(r=T(e,n))||r.enumerable});return t;},_=(t,e,s)=>(a(t,e,"default"),s&&a(s,e,"default")),$=(t,e,s)=>(s=t!=null?m(X(t)):{},a(e||!t||!t.__esModule?E(s,"default",{value:t,enumerable:!0}):s,t));var A=w((ct,v)=>{function C(t){return Array.isArray(t)?t:[t];}var N="",P=" ",h="\\",H=/^\s+$/,F=/(?:[^\\]|^)\\$/,k=/^\\!/,z=/^\\#/,B=/\r?\n/g,K=/^\.*\/|^\.+$/,d="/",x="node-ignore";typeof Symbol<"u"&&(x=Symbol.for("node-ignore"));var L=x,V=(t,e,s)=>Object.defineProperty(t,e,{value:s}),j=/([0-z])-([0-z])/g,G=()=>!1,M=t=>t.replace(j,(e,s,r)=>s.charCodeAt(0)<=r.charCodeAt(0)?e:N),Y=t=>{let{length:e}=t;return t.slice(0,e-e%2);},W=[[/\\?\s+$/,t=>t.indexOf("\\")===0?P:N],[/\\\s/g,()=>P],[/[\\$.|*+(){^]/g,t=>`\\${t}`],[/(?!\\)\?/g,()=>"[^/]"],[/^\//,()=>"^"],[/\//g,()=>"\\/"],[/^\^*\\\*\\\*\\\//,()=>"^(?:.*\\/)?"],[/^(?=[^^])/,function(){return/\/(?!$)/.test(this)?"^":"(?:^|\\/)";}],[/\\\/\\\*\\\*(?=\\\/|$)/g,(t,e,s)=>e+6<s.length?"(?:\\/[^\\/]+)*":"\\/.+"],[/(^|[^\\]+)(\\\*)+(?=.+)/g,(t,e,s)=>{let r=s.replace(/\\\*/g,"[^\\/]*");return e+r;}],[/\\\\\\(?=[$.|*+(){^])/g,()=>h],[/\\\\/g,()=>h],[/(\\)?\[([^\]/]*?)(\\*)($|\])/g,(t,e,s,r,n)=>e===h?`\\[${s}${Y(r)}${n}`:n==="]"&&r.length%2===0?`[${M(s)}${r}]`:"[]"],[/(?:[^*])$/,t=>/\/$/.test(t)?`${t}$`:`${t}(?=$|\\/$)`],[/(\^|\\\/)?\\\*$/,(t,e)=>`${e?`${e}[^/]+`:"[^/]*"}(?=$|\\/$)`]],S=Object.create(null),p=(t,e)=>{let s=S[t];return s||(s=W.reduce((r,n)=>r.replace(n[0],n[1].bind(t)),t),S[t]=s),e?new RegExp(s,"i"):new RegExp(s);},R=t=>typeof t=="string",q=t=>t&&R(t)&&!H.test(t)&&!F.test(t)&&t.indexOf("#")!==0,J=t=>t.split(B),f=class{constructor(e,s,r,n){this.origin=e,this.pattern=s,this.negative=r,this.regex=n;}},Q=(t,e)=>{let s=t,r=!1;t.indexOf("!")===0&&(r=!0,t=t.substr(1)),t=t.replace(k,"!").replace(z,"#");let n=p(t,e);return new f(s,t,r,n);},U=(t,e)=>{throw new e(t);},i=(t,e,s)=>R(t)?t?i.isNotRelative(t)?s(`path should be a \`path.relative()\`d string, but got "${e}"`,RangeError):!0:s("path must not be empty",TypeError):s(`path must be a string, but got \`${e}\``,TypeError),O=t=>K.test(t);i.isNotRelative=O;i.convert=t=>t;var g=class{constructor({ignorecase:e=!0,ignoreCase:s=e,allowRelativePaths:r=!1}={}){V(this,L,!0),this._rules=[],this._ignoreCase=s,this._allowRelativePaths=r,this._initCache();}_initCache(){this._ignoreCache=Object.create(null),this._testCache=Object.create(null);}_addPattern(e){if(e&&e[L]){this._rules=this._rules.concat(e._rules),this._added=!0;return;}if(q(e)){let s=Q(e,this._ignoreCase);this._added=!0,this._rules.push(s);}}add(e){return this._added=!1,C(R(e)?J(e):e).forEach(this._addPattern,this),this._added&&this._initCache(),this;}addPattern(e){return this.add(e);}_testOne(e,s){let r=!1,n=!1;return this._rules.forEach(o=>{let{negative:u}=o;if(n===u&&r!==n||u&&!r&&!n&&!s)return;o.regex.test(e)&&(r=!u,n=u);}),{ignored:r,unignored:n};}_test(e,s,r,n){let o=e&&i.convert(e);return i(o,e,this._allowRelativePaths?G:U),this._t(o,s,r,n);}_t(e,s,r,n){if(e in s)return s[e];if(n||(n=e.split(d)),n.pop(),!n.length)return s[e]=this._testOne(e,r);let o=this._t(n.join(d)+d,s,r,n);return s[e]=o.ignored?o:this._testOne(e,r);}ignores(e){return this._test(e,this._ignoreCache,!1).ignored;}createFilter(){return e=>!this.ignores(e);}filter(e){return C(e).filter(this.createFilter());}test(e){return this._test(e,this._testCache,!0);}},l=t=>new g(t),Z=t=>i(t&&i.convert(t),t,G);l.isPathValid=Z;l.default=l;v.exports=l;var tt=t=>/^\\\\\?\\/.test(t)||/["<>|\u0000-\u001F]+/u.test(t)?t:t.replace(/\\/g,"/");i.convert=tt;var et=/^[a-z]:\//i;i.isNotRelative=t=>et.test(t)||O(t);});var c={};D(c,{default:()=>nt});var st=$(A());_(c,$(A()));var{default:I,...rt}=st,nt=I!==void 0?I:rt;const importMeta={url:"file:///home/runner/work/setup-deno/setup-deno/cache.ts",main:import.meta.main};if(importMeta.main){const args=parseArgs(Deno.args,{boolean:["help","dry-run","verbose","lock-write"],negatable:["lock-write"],string:["config"],default:{"lock-write":true},alias:{help:"h","dry-run":"n"},"--":true});const denoDir=Deno.env.get("DENO_DIR");const logLevel=Deno.env.get("CI")==="1"?"DEBUG":args.verbose?"DEBUG":"INFO";setup({handlers:{console:new handlers.ConsoleHandler(logLevel,{formatter:logRecord=>Deno.noColor?[logRecord.levelName,logRecord.msg].join(" "):logRecord.msg})},loggers:{default:{handlers:["console"],"level":logLevel}}});if(args.help){console.log("Usage: cache [-n | --dry-run] [-v | --verbose] [--] [DENO_ARGS...]");Deno.exit(0);}if(args["dry-run"])warning("dry-run mode enabled");if(args.config&&!await exists(args.config)){error(`config file ${args.config} not found`);Deno.exit(1);}const hash=await Deno.readFile("./deno.lock").then(data=>crypto.subtle.digest("SHA-256",data)).then(data=>crypto.subtle.digest("SHA-256",data)).then(data=>encodeHex(new Uint8Array(data))).catch(_=>"<no deno.lock found>");debug(`GitHub actions deno.lock hash: ${hash}`);const cfgs=args.config?[args.config]:["deno.json","deno.jsonc"];const denoCfg=await Promise.all(cfgs.map(path=>Deno.readTextFile(path).catch(_=>undefined))).then(v=>parse(v.filter(Boolean)[0]??"{}"));const patterns=[...[denoCfg?.exclude??[]].flat(),...[denoCfg?.cache?.exclude??[]].flat(),...[denoCfg?.cache?.include??[]].flatMap(p=>`!${p}`)];debug(`patterns:`,patterns);patterns.forEach(p=>debug(`- ${p}`));const ig=nt().add(patterns);const walkIterator=walk(".",{exts:["js",".jsx",".ts",".tsx"],includeDirs:false});const paths=[];for await(const entry of walkIterator){const relativePath=relative2(".",entry.path);if(denoDir&&entry.path.startsWith(denoDir))continue;if(ig.ignores(relativePath)){debug(`ignored ${relativePath}`);continue;}debug(`caching ${relativePath}`);paths.push(relativePath);}const cmd=new Deno.Command(Deno.execPath(),{args:["cache",args["lock-write"]&&"--lock-write",args.config&&`--config=${args.config}`,...args["--"],...paths].filter(Boolean),stdout:"inherit",stderr:"inherit"});const code=!args["dry-run"]?(await cmd.output()).code:0;if(code===0)debug(`finished caching ${paths.length} files`);}